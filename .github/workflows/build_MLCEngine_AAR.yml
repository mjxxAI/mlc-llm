name: Build MLC Runtime (Regex Patch)

on:
  workflow_dispatch:

jobs:
  build-libs:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      # 1. Free Disk Space (~25GB free)
      - name: Free Disk Space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf /usr/local/share/boost
          sudo docker image prune --all --force

      - name: Checkout Code
        uses: actions/checkout@v4

      # 2. Clone Source (Needed for CMake/Android scripts)
      - name: Clone MLC-LLM Source
        run: git clone --recursive https://github.com/mlc-ai/mlc-llm.git mlc-source

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      # 3. Install MLC Tool
      - name: Install MLC-LLM Nightly
        run: |
          pip install --pre -U -f https://mlc.ai/wheels mlc-llm-nightly-cpu mlc-ai-nightly-cpu

      # 4. FIX: Apply Regex Patch to neutralize the validation check
      - name: Patch MLC Validation Logic
        run: |
          python -c "
          import site
          import os
          import re

          # 1. Locate package.py
          package_dir = site.getsitepackages()[0]
          target_path = os.path.join(package_dir, 'mlc_llm', 'interface', 'package.py')
          print(f'Patching file: {target_path}')

          with open(target_path, 'r') as f:
              content = f.read()

          # 2. Define Regex Pattern
          pattern = r'raise ValueError\(([^)]*?bundle_weight.*?true.*?)\)'
          
          # 3. Check if pattern exists before replacing
          match = re.search(pattern, content, re.DOTALL | re.IGNORECASE)
          if match:
              print('Found the validation check. Neutralizing it...')
              new_content = re.sub(pattern, r'print(\1)', content, flags=re.DOTALL | re.IGNORECASE)
              
              with open(target_path, 'w') as f:
                  f.write(new_content)
              print('Successfully patched package.py')
          else:
              print('WARNING: Regex did not match any ValueError with bundle_weight.')
              print('File start:', content[:500])
          "

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Install NDK & CMake
        run: sdkmanager "ndk;27.0.12077973" "cmake;3.22.1"

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal

      # 5. Download ONLY Configs (No Weights)
      - name: Download Model Configs
        run: |
          mkdir -p models
          python -c "
          import os, requests
          models = {
            'mlc-ai/Qwen2.5-Coder-3B-Instruct-q4f16_1-MLC': 'qwen2.5-coder-3b-instruct',
            'mlc-ai/Qwen3-4B-q4f16_1-MLC': 'qwen3-4b',
            'mlc-ai/Qwen2-Math-7B-Instruct-q4f16_1-MLC': 'qwen2-math-7b-instruct',
            'mlc-ai/Qwen2.5-Coder-7B-Instruct-q4f16_1-MLC': 'qwen2.5-coder-7b-instruct',
            'mlc-ai/Qwen2.5-7B-Instruct-q4f16_1-MLC': 'qwen2.5-7b-instruct',
            'mlc-ai/gemma-3-4b-it-q4f16_1-MLC': 'gemma-3-4b-it',
            'mlc-ai/Llama-3.2-3B-Instruct-q4f16_1-MLC': 'llama-3.2-3b-instruct',
            'mlc-ai/Phi-3.5-mini-instruct-q4f16_1-MLC': 'phi-3.5-mini-instruct',
            'mlc-ai/Phi-3-mini-4k-instruct-q4f16_1-MLC': 'phi-3-mini-4k-instruct'
          }
          files = ['mlc-chat-config.json', 'tokenizer.json', 'tokenizer_config.json', 'ndarray-cache.json']
          for repo, name in models.items():
              path = os.path.join('models', name)
              os.makedirs(path, exist_ok=True)
              print(f'Processing {name}...')
              for f in files:
                  try:
                      r = requests.get(f'https://huggingface.co/{repo}/resolve/main/{f}')
                      if r.status_code == 200:
                          with open(os.path.join(path, f), 'wb') as file: file.write(r.content)
                  except: pass
          "

      # 6. Generate Config pointing to Local Paths
      - name: Create Model Config
        run: |
          cat <<EOF > mlc-package-config.json
          {
            "device": "android",
            "model_list": [
              { "model": "./models/qwen2.5-coder-3b-instruct", "model_id": "qwen2.5-coder-3b-instruct", "estimated_vram_bytes": 3000000000, "bundle_weight": false },
              { "model": "./models/qwen3-4b", "model_id": "qwen3-4b", "estimated_vram_bytes": 3500000000, "bundle_weight": false },
              { "model": "./models/qwen2-math-7b-instruct", "model_id": "qwen2-math-7b-instruct", "estimated_vram_bytes": 4600000000, "bundle_weight": false },
              { "model": "./models/qwen2.5-coder-7b-instruct", "model_id": "qwen2.5-coder-7b-instruct", "estimated_vram_bytes": 4600000000, "bundle_weight": false },
              { "model": "./models/qwen2.5-7b-instruct", "model_id": "qwen2.5-7b-instruct", "estimated_vram_bytes": 4600000000, "bundle_weight": false },
              { "model": "./models/gemma-3-4b-it", "model_id": "gemma-3-4b-it", "estimated_vram_bytes": 3200000000, "bundle_weight": false },
              { "model": "./models/llama-3.2-3b-instruct", "model_id": "llama-3.2-3b-instruct", "estimated_vram_bytes": 2600000000, "bundle_weight": false },
              { "model": "./models/phi-3.5-mini-instruct", "model_id": "phi-3.5-mini-instruct", "estimated_vram_bytes": 2800000000, "bundle_weight": false },
              { "model": "./models/phi-3-mini-4k-instruct", "model_id": "phi-3-mini-4k-instruct", "estimated_vram_bytes": 2800000000, "bundle_weight": false }
            ]
          }
          EOF
      
      - name: Make configs JIT-compatible
        run: |
          python -c "
          import json, glob, os
          for cfg_path in glob.glob('models/**/mlc-chat-config.json', recursive=True):
              print('JIT-enabling', cfg_path)
              cfg = json.load(open(cfg_path))
              cfg.pop('model_lib', None)          # remove baked hash
              cfg['model_lib_path'] = ''          # force JIT
              cfg['prefill_chunk_size'] = 128
              cfg['temporary_buffer_size_mb'] = 1800
              cfg['gpu_memory_utilization'] = 0.99
              json.dump(cfg, open(cfg_path, 'w'), indent=2)
          "

      # 7. Compile
      - name: Compile Runtime Libraries
        env:
          MLC_LLM_SOURCE_DIR: ${{ github.workspace }}/mlc-source
          ANDROID_NDK: ${{ env.ANDROID_HOME }}/ndk/27.0.12077973
          TVM_NDK_CC: ${{ env.ANDROID_HOME }}/ndk/27.0.12077973/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android24-clang
        run: |
          python -m mlc_llm package
          
      # 8. PREPARE GRADLE PROJECT STRUCTURE
      - name: Scaffold Godot Plugin Project
        run: |
          mkdir -p android_build/mlc-godot/libs
          mkdir -p android_build/mlc-godot/src/main/java/com/forge/mlc
          mkdir -p android_build/mlc-godot/src/main/java/ai/mlc/mlcllm
          mkdir -p android_build/mlc-godot/src/main/jniLibs/arm64-v8a
          mkdir -p android_build/mlc-godot/src/main/assets

          # 1. Create Root build.gradle (Vital for resolving Android Plugins)
          cat <<EOF > android_build/build.gradle
          buildscript {
              repositories {
                  google()
                  mavenCentral()
              }
              dependencies {
                  classpath 'com.android.tools.build:gradle:8.2.0'
                  classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.9.22'
              }
          }
          allprojects {
              repositories {
                  google()
                  mavenCentral()
              }
          }
          EOF

          # 2. Create settings.gradle
          echo "include ':mlc-godot'" > android_build/settings.gradle

          # 3. Create Module build.gradle
          # Note: We remove the version numbers here because they are defined in the root buildscript
          cat <<EOF > android_build/mlc-godot/build.gradle
          plugins {
              id 'com.android.library'
              id 'org.jetbrains.kotlin.android'
          }
          android {
              namespace 'com.forge.mlc'
              compileSdk 34
              defaultConfig { 
                  minSdk 24
                  targetSdk 34 
              }
              sourceSets { 
                  main { 
                      jniLibs.srcDirs = ['src/main/jniLibs'] 
                  } 
              }
          }
          dependencies {
              compileOnly 'org.godotengine:godot:4.2.0.stable'
              implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3'
              implementation files('libs/tvm4j_core.jar')
          }
          EOF

          # 4. Create AndroidManifest.xml
          cat <<EOF > android_build/mlc-godot/src/main/AndroidManifest.xml
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">
              <application>
                  <meta-data android:name="org.godotengine.plugin.v1.MLCEngine" android:value="com.forge.mlc.GodotMLCPlugin" />
              </application>
          </manifest>
          EOF

      # 9. INJECT ARTIFACTS & WRAPPER (DYNAMIC FIX)
      - name: Inject Artifacts into Gradle Project
        run: |
          echo "üîç Searching for build artifacts..."
          
          # A. Locate and Copy Shared Object (.so)
          SO_PATH=$(find . -name "libtvm4j_runtime_packed.so" -type f | head -n 1)
          if [ -z "$SO_PATH" ]; then
            echo "‚ùå CRITICAL: libtvm4j_runtime_packed.so NOT FOUND."
            ls -R
            exit 1
          fi
          echo "‚úÖ Found .so at: $SO_PATH"
          cp "$SO_PATH" android_build/mlc-godot/src/main/jniLibs/arm64-v8a/

          # B. Locate and Copy Core JAR
          JAR_PATH=$(find . -name "tvm4j_core.jar" -type f | head -n 1)
          if [ -z "$JAR_PATH" ]; then
            echo "‚ùå CRITICAL: tvm4j_core.jar NOT FOUND."
            exit 1
          fi
          echo "‚úÖ Found .jar at: $JAR_PATH"
          cp "$JAR_PATH" android_build/mlc-godot/libs/

          # C. Locate and Copy Kotlin Sources
          KT_PATH=$(find . -name "MLCEngine.kt" -type f | head -n 1)
          if [ -z "$KT_PATH" ]; then
            echo "‚ùå CRITICAL: MLCEngine.kt NOT FOUND."
            exit 1
          fi
          echo "‚úÖ Found Kotlin source at: $KT_PATH"
          SRC_DIR=$(dirname "$KT_PATH")
          cp -r "$SRC_DIR/"* android_build/mlc-godot/src/main/java/ai/mlc/mlcllm/

          # D. Write the Godot Wrapper
          cat <<EOF > android_build/mlc-godot/src/main/java/com/forge/mlc/GodotMLCPlugin.kt
          package com.forge.mlc

          import android.util.Log
          import org.godotengine.godot.Godot
          import org.godotengine.godot.plugin.GodotPlugin
          import org.godotengine.godot.plugin.UsedByGodot
          import ai.mlc.mlcllm.MLCEngine
          import ai.mlc.mlcllm.OpenAIProtocol
          import kotlinx.coroutines.GlobalScope
          import kotlinx.coroutines.launch
          import java.util.UUID
          import java.util.ArrayList

          class GodotMLCPlugin(godot: Godot) : GodotPlugin(godot) {

              private var engine: MLCEngine? = null
              private var isReady = false

              override fun getPluginName() = "MLCEngine"

              override fun getPluginSignals(): Set<org.godotengine.godot.plugin.SignalInfo> {
                  return setOf(org.godotengine.godot.plugin.SignalInfo("model_loaded"))
              }

              @UsedByGodot
              fun loadModel(modelPath: String) {
                  Log.d("GodotMLC", "Loading model: \$modelPath")
                  engine = MLCEngine()
                  GlobalScope.launch {
                      try {
                          engine?.reload(modelPath, "float16")
                          isReady = true
                          emitSignal("model_loaded")
                      } catch (e: Exception) {
                          Log.e("GodotMLC", "Load Failed", e)
                      }
                  }
              }

              @UsedByGodot
              fun generate(prompt: String): String {
                  if (!isReady || engine == null) return "Error: Engine not ready"
                  
                  return try {
                      val messages = ArrayList<OpenAIProtocol.ChatCompletionMessage>()
                      messages.add(OpenAIProtocol.ChatCompletionMessage(role = "user", content = prompt))
                      val result = engine?.chatCompletion(messages, stream = false)
                      if (result != null && result.choices.isNotEmpty()) {
                          result.choices[0].message.content ?: ""
                      } else {
                          "Error: Empty response"
                      }
                  } catch (e: Exception) {
                      Log.e("GodotMLC", "Gen Failed", e)
                      "Error: \${e.message}"
                  }
              }

              @UsedByGodot
              fun unload() {
                  engine?.unload()
                  isReady = false
              }
          }
          EOF

      # 10. BUILD THE AAR
      - name: Build Godot Plugin AAR
        working-directory: android_build
        run: |
          chmod +x gradlew || true
          # FORCE Gradle 8.5 to be compatible with AGP 8.2.0
          gradle wrapper --gradle-version 8.5
          ./gradlew :mlc-godot:assembleRelease

      # 11. UPLOAD FINAL AAR
      - name: Upload MLCEngine AAR
        uses: actions/upload-artifact@v4
        with:
          name: godot-mlc-plugin
          path: android_build/mlc-godot/build/outputs/aar/mlc-godot-release.aar
